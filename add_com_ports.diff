diff --git a/CMakeLists.txt b/CMakeLists.txt
index f319d4a..409fc1f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -11,7 +11,7 @@ set(CMAKE_AUTOMOC ON)
 set(CMAKE_AUTORCC ON)
 set(CMAKE_AUTOUIC ON)
 
-find_package(Qt6 REQUIRED COMPONENTS Widgets Charts)
+find_package(Qt6 REQUIRED COMPONENTS Widgets Charts SerialPort)
 
 add_library(hub_core
   core/src/Framer.cpp
@@ -62,4 +62,4 @@ target_sources(softionics_hub_gui PRIVATE $<TARGET_OBJECTS:hub_models>)
 
 set_source_files_properties(apps/gui/BleWorker.cpp PROPERTIES SKIP_AUTOMOC ON)
 
-target_link_libraries(softionics_hub_gui PRIVATE Qt6::Widgets Qt6::Charts hub_core)
+target_link_libraries(softionics_hub_gui PRIVATE Qt6::Widgets Qt6::Charts Qt6::SerialPort hub_core)
diff --git a/apps/gui/BleWorker.cpp b/apps/gui/BleWorker.cpp
index c5702d3..8f95526 100644
--- a/apps/gui/BleWorker.cpp
+++ b/apps/gui/BleWorker.cpp
@@ -2,6 +2,7 @@
 #include <algorithm>
 #include <chrono>
 #include <cstring>
+#include <QByteArray>
 #include <QMetaObject>
 
 static inline uint64_t now_ns() {
@@ -52,11 +53,11 @@ void BleWorker::startAuto(QString prefix) {
     prefix_ = prefix;
 
     if (!adapter_) {
-        emit statusText("No Bluetooth adapter");
-        return;
+        emit statusText("No Bluetooth adapter (Serial only)");
+    } else {
+        emit statusText("Scanning...");
     }
 
-    emit statusText("Scanning...");
     startScanning();
 }
 
@@ -73,12 +74,14 @@ void BleWorker::stopScanning() {
 
 void BleWorker::scanLoop() {
     while (scanning_.load() && !quitting_.load()) {
-        try {
-            adapter_->scan_for(1000);
-            auto results = adapter_->scan_get_results();
+        QVector<DeviceInfo> list;
+
+        // --- BLE scan (optional) ---
+        if (adapter_) {
+            try {
+                adapter_->scan_for(1000);
+                auto results = adapter_->scan_get_results();
 
-            QVector<DeviceInfo> list;
-            {
                 QMutexLocker lk(&periphMu_);
                 peripherals_.clear();
                 peripherals_.reserve(results.size());
@@ -90,28 +93,162 @@ void BleWorker::scanLoop() {
                     peripherals_.push_back(p);
 
                     DeviceInfo d;
+                    d.kind = DeviceKind::Ble;
                     d.name = QString::fromStdString(p.identifier());
                     d.address = QString::fromStdString(p.address());
                     d.rssi = p.rssi();
                     list.push_back(d);
                 }
+            } catch (...) {
+                emit statusText("Scan error");
+                QMutexLocker lk(&periphMu_);
+                peripherals_.clear();
             }
+        } else {
+            QMutexLocker lk(&periphMu_);
+            peripherals_.clear();
+        }
 
-            emit scanUpdated(list);
+        // --- Serial ports (COM) ---
+        try {
+            const auto ports = QSerialPortInfo::availablePorts();
+            for (const auto& pi : ports) {
+                QString port = pi.portName();
+                if (port.isEmpty()) continue;
+
+                QString friendly = port;
+
+                QString desc = pi.description();
+                QString manu = pi.manufacturer();
+
+                if (!desc.isEmpty()) friendly += " - " + desc;
+                if (!manu.isEmpty() && (desc.isEmpty() || !desc.contains(manu))) friendly += " (" + manu + ")";
+
+                DeviceInfo d;
+                d.kind = DeviceKind::Serial;
+                d.name = friendly;
+                d.address = port; // unique id / connect key
+                d.rssi = 0;
+                list.push_back(d);
+            }
         } catch (...) {
-            emit statusText("Scan error");
+            // ignore
         }
 
+        {
+            QMutexLocker lk(&scanMu_);
+            lastScan_ = list;
+        }
+
+        emit scanUpdated(list);
+
         std::this_thread::sleep_for(std::chrono::milliseconds(120));
     }
 }
 
-void BleWorker::connectToIndex(int index) {
-    if (!adapter_) return;
+void BleWorker::serialConnect(const QString& portName) {
+    if (portName.isEmpty()) {
+        emit statusText("Connect failed: Serial port empty");
+        return;
+    }
+
+    if (!serial_) {
+        serial_ = new QSerialPort(this);
+        connect(serial_, &QSerialPort::readyRead, this, &BleWorker::onSerialReadyRead);
+        connect(serial_, &QSerialPort::errorOccurred, this, &BleWorker::onSerialError);
+    } else {
+        if (serial_->isOpen()) serial_->close();
+    }
+
+    serialPort_ = portName;
+
+    serial_->setPortName(portName);
+    serial_->setBaudRate(QSerialPort::Baud115200);
+    serial_->setDataBits(QSerialPort::Data8);
+    serial_->setParity(QSerialPort::NoParity);
+    serial_->setStopBits(QSerialPort::OneStop);
+    serial_->setFlowControl(QSerialPort::NoFlowControl);
+
+    if (!serial_->open(QIODevice::ReadOnly)) {
+        emit statusText(QString("Connect failed: Serial open: %1").arg(serial_->errorString()));
+        serialPort_.clear();
+        return;
+    }
+
+    framer_.clear();
+    stream_t0_ns_.store(now_ns());
+
+    {
+        QMutexLocker lk(&pipeMu_);
+        pipe_.reset();
+        pipe_.set_config(cfg_);
+        lastBiasHas_ = pipe_.bias_has();
+        lastBiasCapturing_ = pipe_.bias_capturing();
+        resetStreamStatsLocked();
+    }
+
+    emit biasStateChanged(lastBiasHas_, lastBiasCapturing_);
+    emit streamStats(0, 0.0, 0, 0.0);
+
+    n_ch_.store(0);
+    ok_.store(0);
+    bad_.store(0);
+
+    linkType_.store(2);
+    connected_.store(true);
+}
+
+void BleWorker::serialDisconnect() {
+    if (serial_) {
+        if (serial_->isOpen()) serial_->close();
+    }
+    serialPort_.clear();
+}
 
+void BleWorker::connectToIndex(int index) {
     bool wasScanning = scanning_.load();
     stopScanning();
 
+    DeviceInfo target;
+    {
+        QMutexLocker lk(&scanMu_);
+        if (index < 0 || index >= lastScan_.size()) {
+            if (wasScanning) startScanning();
+            return;
+        }
+        target = lastScan_[index];
+    }
+
+    // --- Serial ---
+    if (target.kind == DeviceKind::Serial) {
+        // ✅ 같은 장치 재클릭으로 disconnect 토글하지 않음 (아무 것도 안 함)
+        if (connected_.load() && linkType_.load() == 2 && serial_ && serial_->isOpen() && serialPort_ == target.address) {
+            emit statusText("Already connected");
+            if (wasScanning) startScanning();
+            return;
+        }
+
+        if (connected_.load()) disconnectDevice();
+
+        emit statusText("Connecting...");
+        serialConnect(target.address);
+
+        if (connected_.load() && linkType_.load() == 2) {
+            emit connected(target.name, target.address);
+            emit statusText("Connected");
+        }
+
+        if (wasScanning) startScanning();
+        return;
+    }
+
+    // --- BLE ---
+    if (!adapter_) {
+        emit statusText("No Bluetooth adapter");
+        if (wasScanning) startScanning();
+        return;
+    }
+
     SimpleBLE::Peripheral p;
     {
         QMutexLocker lk(&periphMu_);
@@ -124,7 +261,7 @@ void BleWorker::connectToIndex(int index) {
 
     try {
         // ✅ 같은 장치 재클릭으로 disconnect 토글하지 않음 (아무 것도 안 함)
-        if (connected_.load() && active_ && active_->address() == p.address()) {
+        if (connected_.load() && linkType_.load() == 1 && active_ && active_->address() == p.address()) {
             emit statusText("Already connected");
             if (wasScanning) startScanning();
             return;
@@ -159,6 +296,9 @@ void BleWorker::connectToIndex(int index) {
             });
         } catch (...) {}
 
+        framer_.clear();
+        stream_t0_ns_.store(now_ns());
+
         {
             QMutexLocker lk(&pipeMu_);
             pipe_.reset();
@@ -175,9 +315,11 @@ void BleWorker::connectToIndex(int index) {
         ok_.store(0);
         bad_.store(0);
 
-        notifyStart();
+        linkType_.store(1);
         connected_.store(true);
 
+        notifyStart();
+
         emit connected(QString::fromStdString(p.identifier()), QString::fromStdString(p.address()));
         emit statusText("Connected");
     } catch (...) {
@@ -192,12 +334,21 @@ void BleWorker::disconnectDevice() {
     // 중복/재진입 방지
     if (!connected_.exchange(false)) return;
 
-    try { notifyStop(); } catch (...) {}
-    try { if (active_) active_->disconnect(); } catch (...) {}
+    int lt = linkType_.exchange(0);
 
-    active_.reset();
-    svc_.reset();
-    chr_.reset();
+    if (lt == 1) {
+        try { notifyStop(); } catch (...) {}
+        try { if (active_) active_->disconnect(); } catch (...) {}
+
+        active_.reset();
+        svc_.reset();
+        chr_.reset();
+    } else if (lt == 2) {
+        serialDisconnect();
+    }
+
+    stream_t0_ns_.store(0);
+    framer_.clear();
 
     stopCsv();
 
@@ -215,132 +366,174 @@ void BleWorker::disconnectDevice() {
     emit statusText("Scanning...");
 
     // 스캔이 꺼져있을 수도 있으니 보장
-    if (adapter_ && !scanning_.load() && !quitting_.load()) startScanning();
+    if (!scanning_.load() && !quitting_.load()) startScanning();
 }
 
 void BleWorker::notifyStart() {
     if (!active_ || !svc_ || !chr_) return;
 
-    uint64_t stream_t0 = now_ns();
-
-    active_->notify(*svc_, *chr_, [this, stream_t0](SimpleBLE::ByteArray payload) {
+    active_->notify(*svc_, *chr_, [this](SimpleBLE::ByteArray payload) {
         if (!connected_.load()) return;
+        if (linkType_.load() != 1) return;
 
         std::string chunk(payload.begin(), payload.end());
-        auto lines = framer_.push(chunk);
-
-        for (auto& line : lines) {
-            auto v = parser_.parse_line(line);
-            if (!v) { bad_.fetch_add(1); continue; }
-
-            size_t n = v->size();
-
-            if (n_ch_.load() == 0) {
-                n_ch_.store(n);
-                QMutexLocker lk(&pipeMu_);
-                pipe_.ensure_initialized(n);
-                lastBiasHas_ = pipe_.bias_has();
-                lastBiasCapturing_ = pipe_.bias_capturing();
-                resetStreamStatsLocked();
-                emit biasStateChanged(lastBiasHas_, lastBiasCapturing_);
-                emit streamStats(0, 0.0, 0, 0.0);
-            }
+        this->processChunk(std::string_view(chunk));
+    });
+}
 
-            if (n_ch_.load() != n) { bad_.fetch_add(1); continue; }
+void BleWorker::notifyStop() {
+    if (!active_ || !svc_ || !chr_) return;
+    active_->unsubscribe(*svc_, *chr_);
+}
 
-            uint64_t t = now_ns();
+void BleWorker::onSerialReadyRead() {
+    if (!connected_.load()) return;
+    if (linkType_.load() != 2) return;
+    if (!serial_) return;
 
-            hub::PipelineOut out;
-            bool cap = false;
-            bool has = false;
-            bool emitBias = false;
-            bool emitStream = false;
+    QByteArray data = serial_->readAll();
+    if (data.isEmpty()) return;
 
-            qulonglong totalSamples = 0;
-            double totalTimeSec = 0.0;
-            qulonglong last1sSamples = 0;
-            double lastDtSec = 0.0;
+    std::string chunk(data.constData(), (size_t)data.size());
+    processChunk(std::string_view(chunk));
+}
 
-            {
-                QMutexLocker lk(&pipeMu_);
+void BleWorker::onSerialError(QSerialPort::SerialPortError error) {
+    if (error == QSerialPort::NoError) return;
+    if (!connected_.load()) return;
+    if (linkType_.load() != 2) return;
+    if (quitting_.load()) return;
+    if (!serial_) return;
+
+    // unplug / fatal errors
+    if (error == QSerialPort::ResourceError ||
+        error == QSerialPort::DeviceNotFoundError ||
+        error == QSerialPort::PermissionError ||
+        error == QSerialPort::OpenError) {
+
+        emit statusText(QString("Serial error: %1").arg(serial_->errorString()));
+
+        QMetaObject::invokeMethod(this, [this]() {
+            if (quitting_.load()) return;
+            disconnectDevice();
+        }, Qt::QueuedConnection);
+    }
+}
 
-                out = pipe_.process(t, *v);
-                cap = pipe_.bias_capturing();
-                has = pipe_.bias_has();
+void BleWorker::processChunk(std::string_view chunk) {
+    if (!connected_.load()) return;
 
-                if (cap != lastBiasCapturing_ || has != lastBiasHas_) {
-                    lastBiasCapturing_ = cap;
-                    lastBiasHas_ = has;
-                    emitBias = true;
-                }
+    uint64_t stream_t0 = stream_t0_ns_.load();
+    if (stream_t0 == 0) stream_t0 = now_ns();
 
-                st_total_samples_ += 1;
+    auto lines = framer_.push(chunk);
 
-                uint64_t tn = (uint64_t)out.frame.t_ns;
-                if (st_first_ns_ == 0) st_first_ns_ = tn;
+    for (auto& line : lines) {
+        auto v = parser_.parse_line(line);
+        if (!v) { bad_.fetch_add(1); continue; }
 
-                if (st_prev_ns_ != 0) st_last_dt_ns_ = tn - st_prev_ns_;
-                else st_last_dt_ns_ = 0;
+        size_t n = v->size();
 
-                st_prev_ns_ = tn;
-                st_last_ns_ = tn;
+        if (n_ch_.load() == 0) {
+            n_ch_.store(n);
+            QMutexLocker lk(&pipeMu_);
+            pipe_.ensure_initialized(n);
+            lastBiasHas_ = pipe_.bias_has();
+            lastBiasCapturing_ = pipe_.bias_capturing();
+            resetStreamStatsLocked();
+            emit biasStateChanged(lastBiasHas_, lastBiasCapturing_);
+            emit streamStats(0, 0.0, 0, 0.0);
+        }
 
-                st_last1s_ts_.push_back(tn);
-                while (!st_last1s_ts_.empty() && (tn - st_last1s_ts_.front()) > 1000000000ULL) {
-                    st_last1s_ts_.pop_front();
-                }
+        if (n_ch_.load() != n) { bad_.fetch_add(1); continue; }
 
-                if (st_last_emit_ns_ == 0 || (tn - st_last_emit_ns_) >= 200000000ULL) {
-                    st_last_emit_ns_ = tn;
-                    emitStream = true;
+        uint64_t t = now_ns();
 
-                    totalSamples = (qulonglong)st_total_samples_;
-                    totalTimeSec = (st_last_ns_ > st_first_ns_) ? (double)(st_last_ns_ - st_first_ns_) * 1e-9 : 0.0;
-                    last1sSamples = (qulonglong)st_last1s_ts_.size();
-                    lastDtSec = (double)st_last_dt_ns_ * 1e-9;
-                }
+        hub::PipelineOut out;
+        bool cap = false;
+        bool has = false;
+        bool emitBias = false;
+        bool emitStream = false;
+
+        qulonglong totalSamples = 0;
+        double totalTimeSec = 0.0;
+        qulonglong last1sSamples = 0;
+        double lastDtSec = 0.0;
+
+        {
+            QMutexLocker lk(&pipeMu_);
+
+            out = pipe_.process(t, *v);
+            cap = pipe_.bias_capturing();
+            has = pipe_.bias_has();
+
+            if (cap != lastBiasCapturing_ || has != lastBiasHas_) {
+                lastBiasCapturing_ = cap;
+                lastBiasHas_ = has;
+                emitBias = true;
             }
 
-            if (emitBias) emit biasStateChanged(has, cap);
-            if (emitStream) emit streamStats(totalSamples, totalTimeSec, last1sSamples, lastDtSec);
-
-            ok_.fetch_add(1);
-
-            if (csvOn_.load()) {
-                QMutexLocker lk(&csvMu_);
-                if (csv_ && (*csv_)) {
-                    if (!csvHeaderWritten_) {
-                        (*csv_) << "t";
-                        for (size_t i = 0; i < out.frame.x.size(); ++i) (*csv_) << ",ch" << i;
-                        (*csv_) << "\n";
-                        csvHeaderWritten_ = true;
-                    }
-                    uint64_t base = (csv_t0_ns_ ? csv_t0_ns_ : stream_t0);
-                    double ts = (static_cast<double>(out.frame.t_ns - base)) * 1e-9;
-                    (*csv_) << ts;
-                    for (size_t i = 0; i < out.frame.x.size(); ++i) (*csv_) << "," << out.frame.x[i];
-                    (*csv_) << "\n";
-                }
+            st_total_samples_ += 1;
+
+            uint64_t tn = (uint64_t)out.frame.t_ns;
+            if (st_first_ns_ == 0) st_first_ns_ = tn;
+
+            if (st_prev_ns_ != 0) st_last_dt_ns_ = tn - st_prev_ns_;
+            else st_last_dt_ns_ = 0;
+
+            st_prev_ns_ = tn;
+            st_last_ns_ = tn;
+
+            st_last1s_ts_.push_back(tn);
+            while (!st_last1s_ts_.empty() && (tn - st_last1s_ts_.front()) > 1000000000ULL) {
+                st_last1s_ts_.pop_front();
             }
 
-            QVector<float> qx;
-            qx.reserve((int)out.frame.x.size());
-            for (float f : out.frame.x) qx.push_back(f);
+            if (st_last_emit_ns_ == 0 || (tn - st_last_emit_ns_) >= 200000000ULL) {
+                st_last_emit_ns_ = tn;
+                emitStream = true;
 
-            emit frameReady((qulonglong)out.frame.t_ns, qx, false, 0.0f);
+                totalSamples = (qulonglong)st_total_samples_;
+                totalTimeSec = (st_last_ns_ > st_first_ns_) ? (double)(st_last_ns_ - st_first_ns_) * 1e-9 : 0.0;
+                last1sSamples = (qulonglong)st_last1s_ts_.size();
+                lastDtSec = (double)st_last_dt_ns_ * 1e-9;
+            }
+        }
+
+        if (emitBias) emit biasStateChanged(has, cap);
+        if (emitStream) emit streamStats(totalSamples, totalTimeSec, last1sSamples, lastDtSec);
+
+        ok_.fetch_add(1);
 
-            static thread_local uint64_t lastStats = 0;
-            if (t - lastStats > 500000000ULL) {
-                lastStats = t;
-                emit statsUpdated(ok_.load(), bad_.load());
+        if (csvOn_.load()) {
+            QMutexLocker lk(&csvMu_);
+            if (csv_ && (*csv_)) {
+                if (!csvHeaderWritten_) {
+                    (*csv_) << "t";
+                    for (size_t i = 0; i < out.frame.x.size(); ++i) (*csv_) << ",ch" << i;
+                    (*csv_) << "\n";
+                    csvHeaderWritten_ = true;
+                }
+                uint64_t base = (csv_t0_ns_ ? csv_t0_ns_ : stream_t0);
+                double ts = (static_cast<double>(out.frame.t_ns - base)) * 1e-9;
+                (*csv_) << ts;
+                for (size_t i = 0; i < out.frame.x.size(); ++i) (*csv_) << "," << out.frame.x[i];
+                (*csv_) << "\n";
             }
         }
-    });
-}
 
-void BleWorker::notifyStop() {
-    if (!active_ || !svc_ || !chr_) return;
-    active_->unsubscribe(*svc_, *chr_);
+        QVector<float> qx;
+        qx.reserve((int)out.frame.x.size());
+        for (float f : out.frame.x) qx.push_back(f);
+
+        emit frameReady((qulonglong)out.frame.t_ns, qx, false, 0.0f);
+
+        static thread_local uint64_t lastStats = 0;
+        if (t - lastStats > 500000000ULL) {
+            lastStats = t;
+            emit statsUpdated(ok_.load(), bad_.load());
+        }
+    }
 }
 
 void BleWorker::setPipelineConfig(hub::PipelineConfig cfg) {
diff --git a/apps/gui/BleWorker.h b/apps/gui/BleWorker.h
index 3c28d1b..7c088fd 100644
--- a/apps/gui/BleWorker.h
+++ b/apps/gui/BleWorker.h
@@ -7,6 +7,9 @@
 #include <QMutex>
 #include <QMutexLocker>
 
+#include <QtSerialPort/QSerialPort>
+#include <QtSerialPort/QSerialPortInfo>
+
 #include <atomic>
 #include <fstream>
 #include <memory>
@@ -15,6 +18,7 @@
 #include <optional>
 #include <deque>
 #include <cstdint>
+#include <string_view>
 
 #include <simpleble/SimpleBLE.h>
 
@@ -22,10 +26,16 @@
 #include "hub/Parser.h"
 #include "hub/Pipeline.h"
 
+enum class DeviceKind : int {
+    Ble = 0,
+    Serial = 1,
+};
+
 struct DeviceInfo {
+    DeviceKind kind = DeviceKind::Ble;
     QString name;
     QString address;
-    int rssi = 0;
+    int rssi = 0; // BLE only
 };
 
 class BleWorker : public QObject {
@@ -66,8 +76,17 @@ private:
     void notifyStart();
     void notifyStop();
 
+    void processChunk(std::string_view chunk);
+
+    void serialConnect(const QString& portName);
+    void serialDisconnect();
+
     void resetStreamStatsLocked();
 
+private slots:
+    void onSerialReadyRead();
+    void onSerialError(QSerialPort::SerialPortError error);
+
 private:
     std::atomic<bool> scanning_{false};
     std::atomic<bool> connected_{false};
@@ -80,10 +99,20 @@ private:
     std::vector<SimpleBLE::Peripheral> peripherals_;
     QMutex periphMu_;
 
+    QVector<DeviceInfo> lastScan_;
+    QMutex scanMu_;
+
     std::optional<SimpleBLE::Peripheral> active_;
     std::optional<SimpleBLE::BluetoothUUID> svc_;
     std::optional<SimpleBLE::BluetoothUUID> chr_;
 
+    std::atomic<int> linkType_{0}; // 0 none, 1 BLE, 2 Serial
+
+    QSerialPort* serial_ = nullptr;
+    QString serialPort_;
+
+    std::atomic<uint64_t> stream_t0_ns_{0};
+
     hub::LineFramer framer_;
     hub::CsvFloatParser parser_;
 
diff --git a/apps/gui/MainWindow.cpp b/apps/gui/MainWindow.cpp
index c76fe0d..39d1984 100644
--- a/apps/gui/MainWindow.cpp
+++ b/apps/gui/MainWindow.cpp
@@ -113,7 +113,7 @@ void MainWindow::buildUi() {
     devPanel->setMinimumWidth(280);
     auto* devL = new QVBoxLayout(devPanel);
 
-    auto* devTitle = new QLabel("Devices (click to connect)", devPanel);
+    auto* devTitle = new QLabel("Devices (BLE / COM, click to connect)", devPanel);
     QFont titleFont = devTitle->font();
     titleFont.setBold(true);
     devTitle->setFont(titleFont);
@@ -492,13 +492,22 @@ void MainWindow::onScanUpdated(QVector<DeviceInfo> devices) {
 
     list_->clear();
 
+    auto isSerialId = [](const QString& s) {
+        return s.startsWith("COM", Qt::CaseInsensitive) || s.startsWith("/dev/");
+    };
+
     bool foundConnected = false;
     bool foundConnecting = false;
 
     for (int i = 0; i < devices_.size(); ++i) {
         const auto& d = devices_[i];
 
-        QString text = QString("%1  (%2)  rssi=%3").arg(d.name).arg(d.address).arg(d.rssi);
+        QString text;
+        if (d.kind == DeviceKind::Ble) {
+            text = QString("%1  (%2)  rssi=%3").arg(d.name).arg(d.address).arg(d.rssi);
+        } else {
+            text = QString("[COM] %1").arg(d.name);
+        }
         auto* item = new QListWidgetItem(text);
         item->setData(ROLE_ADDR, d.address);
         item->setData(ROLE_NAME, d.name);
@@ -511,7 +520,9 @@ void MainWindow::onScanUpdated(QVector<DeviceInfo> devices) {
 
     if (!connectedAddr_.isEmpty() && !foundConnected) {
         QString nm = connectedName_.isEmpty() ? "CONNECTED" : connectedName_;
-        QString text = QString("%1  (%2)  rssi=--").arg(nm).arg(connectedAddr_);
+        QString text;
+        if (isSerialId(connectedAddr_)) text = QString("[COM] %1  (%2)").arg(nm).arg(connectedAddr_);
+        else text = QString("%1  (%2)  rssi=--").arg(nm).arg(connectedAddr_);
         auto* item = new QListWidgetItem(text);
         item->setData(ROLE_ADDR, connectedAddr_);
         item->setData(ROLE_NAME, nm);
@@ -521,7 +532,9 @@ void MainWindow::onScanUpdated(QVector<DeviceInfo> devices) {
 
     if (connecting_ && !connectingAddr_.isEmpty() && !foundConnecting) {
         QString nm = connectingName_.isEmpty() ? "CONNECTING" : connectingName_;
-        QString text = QString("%1  (%2)  rssi=--").arg(nm).arg(connectingAddr_);
+        QString text;
+        if (isSerialId(connectingAddr_)) text = QString("[COM] %1  (%2)").arg(nm).arg(connectingAddr_);
+        else text = QString("%1  (%2)  rssi=--").arg(nm).arg(connectingAddr_);
         auto* item = new QListWidgetItem(text);
         item->setData(ROLE_ADDR, connectingAddr_);
         item->setData(ROLE_NAME, nm);
